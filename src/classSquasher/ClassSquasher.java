package classSquasher;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Squashes all your classes into one for use in the codingame platform.<br>
 * Change the values of <code>SOURCE_FOLDER</code> and <code>PACKAGE_ROOT</code> according to your main project<br>
 * <br>
 * Lombok is not supported (by codingame), but you can use the delombok plugin:
 * <pre>{@code
 *   <plugin>
 *     <groupId>org.projectlombok</groupId>
 *     <artifactId>lombok-maven-plugin</artifactId>
 *     <version>1.18.20.0</version>
 *     <executions>
 *       <execution>
 *         <phase>generate-sources</phase>
 *         <goals>
 *           <goal>delombok</goal>
 *         </goals>
 *         <configuration>
 *           <encoding>UTF-8</encoding>
 *           <sourceDirectory>src/main/java</sourceDirectory>
 *         </configuration>
 *       </execution>
 *     </executions>
 *   </plugin>
 * }</pre>
 * to work around that issue.<br>
 * <br>
 * Doesn't support newer modifiers like 'sealed'. (untested, maybe it does work)
 */
public class ClassSquasher {
    public static final String SOURCE_FOLDER = "../CodinGameSpringChallenge2022/target/generated-sources/delombok";
    public static final String PACKAGE_ROOT = "spring2022";
    public static final String MAIN_CLASS = "Player.java";
    public static final String IMPORT_REGEX = "import\\s+[\\w.?]+\\*?;";

    public static void main(String[] args) throws IOException {
        String main = MAIN_CLASS;
        String source = SOURCE_FOLDER;

        List<Path> fileList = getFileListRecursively(Paths.get(source));

        List<String> imports = fileList.stream()
                .flatMap(ClassSquasher::readAllLines)
                .filter(line -> line.matches(IMPORT_REGEX))
                .filter(line -> !line.matches("import " + PACKAGE_ROOT + ".+;"))
                .distinct()
                .collect(Collectors.toList());

        Path sourcePath = Paths.get(source, PACKAGE_ROOT, main);
        List<String> mainFile = readAllLines(sourcePath)
                .filter(ClassSquasher::filterSourceFileLines)
                .collect(Collectors.toList());

        mainFile.remove(mainFile.size() - 1); // remove last line

        List<String> otherClasses = fileList.stream()
                .filter(p -> !p.toFile().getName().equals(main))
                .flatMap(ClassSquasher::readAllLines)
                .filter(ClassSquasher::filterSourceFileLines)
                .map(ClassSquasher::mutateClassDeclaration)
                .collect(Collectors.toList());

        Path outFile = Paths.get("src", main);
        System.out.println(outFile.toAbsolutePath());
        Files.deleteIfExists(outFile);
        Files.createFile(outFile);
        Files.write(outFile, imports);
        Files.write(outFile, mainFile, StandardOpenOption.APPEND);
        Files.write(outFile, otherClasses, StandardOpenOption.APPEND);
        Files.write(outFile, List.of("}"), StandardOpenOption.APPEND);
    }

    private static List<Path> getFileListRecursively(Path path) {
        File file = path.toFile();
        List<Path> result = new ArrayList<>();
        if (file.isDirectory()) {
            //noinspection ConstantConditions
            for (File f : file.listFiles()) {
                 result.addAll(getFileListRecursively(f.toPath()));
            }
        } else {
            result.add(path);
        }
        return result;
    }

    private static boolean filterSourceFileLines(String line) {
        // remove packages and imports
        return !line.startsWith("package") &&
                !line.matches(IMPORT_REGEX) &&
                // remove delombok lines
                !line.startsWith("// Generated by delombok") &&
                !line.contains("@java.lang.SuppressWarnings(\"all\")");


    }

    private static String mutateClassDeclaration(String line) {
        if (line.matches("^(public\\s+)?((abstract +)?class|interface|enum)\\s+[\\w]+(<[A-Za-z ,]+>)?\\s*((extends|implements)\\s+\\w+\\s*)?\\{\\s*$")) {
            return "static " + line.replaceAll("public\\s?", "");
        } else {
            return line;
        }
    }

    private static Stream<String> readAllLines(Path f) {
        try {
            return Files.readAllLines(f).stream();
        } catch (IOException e) {
            // crash and burn
            throw new RuntimeException("Well that sucks", e);
        }
    }
}
